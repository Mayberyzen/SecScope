"""
Backend: simple pentest utilities.

These are intentionally basic and aimed at lab / educational usage.
"""

import platform
import socket
import subprocess
from typing import List,Tuple

try:
    import requests
except ImportError:
    requests = None


def ping_host(host: str, count: int = 4) -> str:
    system = platform.system().lower()
    if "windows" in system:
        cmd = ["ping", "-n", str(count), host]
    else:
        cmd = ["ping", "-c", str(count), host]

    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True, timeout=15)
        return out
    except Exception as e:
        return f"Error running ping: {e}"


def traceroute_host(host: str, max_hops: int = 20) -> str:
    system = platform.system().lower()
    if "windows" in system:
        cmd = ["tracert", "-h", str(max_hops), host]
    else:
        cmd = ["traceroute", "-m", str(max_hops), host]

    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True, timeout=60)
        return out
    except Exception as e:
        return f"Error running traceroute: {e}"


def scan_ports(host: str, ports: List[int], timeout: float = 0.5) -> List[str]:
    """
    Very simple TCP connect scan.
    """
    results = []
    for port in ports:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                res = s.connect_ex((host, port))
                if res == 0:
                    results.append(f"{host}:{port} -> OPEN")
        except Exception as e:
            results.append(f"{host}:{port} -> Error: {e}")
    if not results:
        results.append("No open ports found in given range (or host unreachable).")
    return results


def banner_grab(host: str, port: int, timeout: float = 2.0) -> str:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            s.connect((host, port))
            try:
                s.sendall(b"HEAD / HTTP/1.0\r\n\r\n")
            except Exception:
                pass
            data = s.recv(4096)
            if not data:
                return "No banner received."
            return data.decode(errors="replace")
    except Exception as e:
        return f"Error grabbing banner: {e}"


def enumerate_subdomains(domain: str, wordlist: List[str]) -> List[str]:
    """
    VERY basic DNS-based subdomain brute-forcing.
    """
    found = []
    for sub in wordlist:
        full = f"{sub}.{domain}"
        try:
            socket.gethostbyname(full)
            found.append(full)
        except socket.gaierror:
            continue
    if not found:
        found.append("No subdomains resolved from this tiny wordlist.")
    return found


def dir_bruteforce(base_url: str, wordlist: List[str]) -> List[str]:
    """
    Very small directory brute force using HEAD/GET.

    Requires 'requests' for best results; otherwise uses socket and returns minimal info.
    """
    results = []
    if requests is None:
        results.append("Python 'requests' not installed â€“ directory brute-force disabled.")
        return results

    if not base_url.startswith("http://") and not base_url.startswith("https://"):
        base_url = "http://" + base_url

    base_url = base_url.rstrip("/")

    for word in wordlist:
        url = f"{base_url}/{word}"
        try:
            resp = requests.head(url, timeout=3)
            status = resp.status_code
            if status == 404:
                continue
            results.append(f"{url} -> {status}")
        except Exception:
            continue

    if not results:
        results.append("No interesting paths found (with provided list).")
    return results
